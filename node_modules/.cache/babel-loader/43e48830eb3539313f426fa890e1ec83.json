{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\DELL\\\\Desktop\\\\portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"C:\\\\Users\\\\DELL\\\\Desktop\\\\portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport { resolveElements } from '../render/dom/utils/resolve-element.mjs';\nimport { visualElementStore } from '../render/store.mjs';\nimport { invariant } from '../utils/errors.mjs';\nimport { GroupPlaybackControls } from './GroupPlaybackControls.mjs';\nimport { isDOMKeyframes } from './utils/is-dom-keyframes.mjs';\nimport { animateTarget } from './interfaces/visual-element-target.mjs';\nimport { createVisualElement } from './utils/create-visual-element.mjs';\nimport { animateSingleValue } from './interfaces/single-value.mjs';\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n  var elements = resolveElements(elementOrSelector, scope);\n  var numElements = elements.length;\n  invariant(Boolean(numElements), \"No valid element provided.\");\n  var animations = [];\n  for (var i = 0; i < numElements; i++) {\n    var element = elements[i];\n    /**\n     * Check each element for an associated VisualElement. If none exists,\n     * we need to create one.\n     */\n    if (!visualElementStore.has(element)) {\n      /**\n       * TODO: We only need render-specific parts of the VisualElement.\n       * With some additional work the size of the animate() function\n       * could be reduced significantly.\n       */\n      createVisualElement(element);\n    }\n    var visualElement = visualElementStore.get(element);\n    var transition = _objectSpread({}, options);\n    /**\n     * Resolve stagger function if provided.\n     */\n    if (typeof transition.delay === \"function\") {\n      transition.delay = transition.delay(i, numElements);\n    }\n    animations.push.apply(animations, _toConsumableArray(animateTarget(visualElement, _objectSpread({}, keyframes, {\n      transition: transition\n    }), {})));\n  }\n  return new GroupPlaybackControls(animations);\n}\nvar createScopedAnimate = function createScopedAnimate(scope) {\n  function scopedAnimate(valueOrElement, keyframes, options) {\n    var animation;\n    if (isDOMKeyframes(keyframes)) {\n      animation = animateElements(valueOrElement, keyframes, options, scope);\n    } else {\n      animation = animateSingleValue(valueOrElement, keyframes, options);\n    }\n    if (scope) {\n      scope.animations.push(animation);\n    }\n    return animation;\n  }\n  return scopedAnimate;\n};\nvar animate = createScopedAnimate();\nexport { animate, createScopedAnimate };","map":null,"metadata":{},"sourceType":"module"}